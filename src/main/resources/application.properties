spring.application.name=sprint3-sqlserver

# JPA / Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.open-in-view=false
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
# (Opcional) deixe o dialect sem fixar; o Hibernate detecta sozinho para SQL Server.
# spring.jpa.database-platform=org.hibernate.dialect.SQLServerDialect

# Datasource vem por variáveis do App Service (já configuradas no seu script)
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}
spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver

# Boa prática no Azure SQL: criptografia ativa (coloque no SPRING_DATASOURCE_URL)
# Ex.: jdbc:sqlserver://<server>.database.windows.net:1433;database=<db>;encrypt=true;trustServerCertificate=false;loginTimeout=30;

# Swagger em /swagger-ui/index.html (padrão do springdoc)
springdoc.api-docs.enabled=true
springdoc.swagger-ui.enabled=true

# Respeitar o header X-Forwarded-* do Azure (redirects e links corretos)
server.forward-headers-strategy=framework

# Porta do App Service (usa PORT se existir, senão 8080 local)
server.port=${PORT:8080}

# Cookie de sessão seguro em HTTPS (formLogin)
server.servlet.session.cookie.secure=true

# (Opcional) Domínio do cookie se precisar compartilhar subdomínios
# server.servlet.session.cookie.domain=<seu-dominio>

